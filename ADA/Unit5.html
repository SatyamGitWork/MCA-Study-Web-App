<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit 5: Complexity Classes - ADA</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        @media (min-width: 1024px) {
            .sidebar {
                position: sticky;
                top: 0;
                height: 100vh;
                overflow-y: auto;
            }
        }
        
        /* Code Tabs Styling */
        .code-tabs {
            margin: 1rem 0;
        }
        
        .tab-header {
            display: flex;
            gap: 0.5rem;
            border-bottom: 2px solid #e5e7eb;
            margin-bottom: 1rem;
        }
        
        .tab-btn {
            padding: 0.5rem 1.5rem;
            border: none;
            background: transparent;
            color: #6b7280;
            font-weight: 500;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            transition: all 0.3s ease;
        }
        
        .tab-btn:hover {
            color: #a855f7;
            background-color: #faf5ff;
        }
        
        .tab-btn.active {
            color: #a855f7;
            border-bottom-color: #a855f7;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .tab-content pre {
            background-color: #1e293b;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.875rem;
            line-height: 1.5;
        }
        
        .tab-content code {
            font-family: 'Courier New', Courier, monospace;
        }
        
        /* Graph/SVG Styling */
        .graph-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
            background-color: #f9fafb;
            padding: 15px;
            border-radius: 8px;
        }
        
        .node {
            fill: #e5e7eb;
            stroke: #374151;
            stroke-width: 2;
        }
        
        .node-text {
            font-size: 14px;
            font-weight: bold;
            fill: #1f2937;
            text-anchor: middle;
            dominant-baseline: middle;
            font-family: sans-serif;
        }
        
        .edge {
            stroke: #9ca3af;
            stroke-width: 2;
        }
        
        .edge-highlight {
            stroke: #a855f7;
            stroke-width: 3;
        }
        
        .edge-label {
            font-size: 12px;
            fill: #4b5563;
            font-family: sans-serif;
        }
        
        /* DFS/BFS Step-by-Step Visualization */
        .step-block {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px dashed #d1d5db;
        }
        
        .step-text {
            margin-bottom: 10px;
            font-style: italic;
            color: #4b5563;
        }
        
        .dfs-table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        
        .dfs-table th,
        .dfs-table td {
            border: 1px solid #bdc3c7;
            padding: 8px;
            text-align: center;
        }
        
        .dfs-table th {
            background-color: #a855f7;
            color: white;
            font-weight: bold;
        }
        
        .visited-cell {
            background-color: #90EE90 !important;
            font-weight: bold;
        }
        
        .call-stack-box {
            border: 2px solid #90EE90;
            padding: 8px 12px;
            display: inline-block;
            background: #E8F5E9;
            border-radius: 4px;
            margin: 10px 0;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.95rem;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-purple-50 text-gray-800">

    <div class="flex flex-col lg:flex-row">
        
        <nav class="lg:w-1/4 xl:w-1/5 bg-white shadow-lg p-6 lg:p-8 sidebar">
            <a href="../index.html" class="inline-block mb-4 text-purple-700 hover:text-purple-900 font-medium">
                ‚Üê Back to Home
            </a>
            <h1 class="text-2xl font-bold text-purple-700 mb-2">ADA Guide</h1>
            <p class="text-sm text-gray-600 mb-8">Unit 5: Complexity Classes</p>
            <ul class="space-y-2">
                <li><a href="Unit1.html" class="block px-4 py-2 rounded-lg font-medium text-gray-700 hover:bg-purple-50 hover:text-purple-700">Unit 1</a></li>
                <li><a href="Unit2.html" class="block px-4 py-2 rounded-lg font-medium text-gray-700 hover:bg-purple-50 hover:text-purple-700">Unit 2</a></li>
                <li><a href="Unit3.html" class="block px-4 py-2 rounded-lg font-medium text-gray-700 hover:bg-purple-50 hover:text-purple-700">Unit 3</a></li>
                <li><a href="Unit4.html" class="block px-4 py-2 rounded-lg font-medium text-gray-700 hover:bg-purple-50 hover:text-purple-700">Unit 4</a></li>
                <li><a href="Unit5.html" class="block px-4 py-2 rounded-lg font-medium bg-purple-100 text-purple-700">Unit 5</a></li>
            </ul>
        </nav>

        <main class="w-full lg:w-3/4 xl:w-4/5 p-6 md:p-10 lg:p-12">
            
            <div class="bg-white rounded-lg shadow-md p-6 lg:p-8 mb-8">
                <h1 class="text-3xl font-bold text-purple-800 mb-2">Unit 5</h1>
                <p class="text-lg text-gray-600">P, NP, NP-Hard, and Travelling Salesman Problem</p>
            </div>

            <h2 class="text-2xl font-bold text-purple-800 mb-4">Short Answer Questions</h2>

        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <div class="text-lg font-semibold text-purple-700 mb-3">Question 1: Define the complexity classes P and NP, and briefly explain the relationship between them.</div>
            <div class="text-gray-700 leading-relaxed">
                <p><strong>Answer:</strong> The class P (Polynomial time) includes all decision problems that can be solved by a deterministic Turing machine in polynomial time, meaning an efficient algorithm exists to find the solution. The class NP (Non-deterministic Polynomial time) includes all decision problems for which a potential solution, or "certificate," can be verified in polynomial time by a deterministic Turing machine.</p>
                <p>Every problem in P is also in NP \((P \subseteq NP)\), because if a problem can be solved quickly, its solution can certainly be verified quickly. The central, unanswered question in computer science is whether \(P=NP\), which essentially asks if problems that are easy to check are also easy to solve.</p>
            </div>
        </div>

        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <div class="text-lg font-semibold text-purple-700 mb-3">Question 2: Explain the concepts of Polynomial Reduction and NP-Hardness.</div>
            <div class="text-gray-700 leading-relaxed">
                <p><strong>Answer:</strong> A Polynomial Reduction (or polynomial-time transformation) is a procedure where an instance of one problem, A, is transformed into an equivalent instance of another problem, B, such that the transformation takes polynomial time. If A can be reduced to B \((A \le_{P} B)\), then B is at least as hard as A.</p>
                <p>A decision problem H is NP-Hard if every problem in NP can be reduced to H in polynomial time. If an NP-Hard problem H is also in the class NP itself, it is then called NP-Complete (NPC). Proving a problem is NPC requires showing it's in NP and then showing a known NPC problem reduces to it.</p>
            </div>
        </div>

        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <div class="text-lg font-semibold text-purple-700 mb-3">Question 3: State Cook's Theorem.</div>
            <div class="text-gray-700 leading-relaxed">
                <p><strong>Answer:</strong> Cook's Theorem (formally the Cook-Levin Theorem) states that the Satisfiability Problem (SAT) is NP-Complete. SAT is the problem of determining whether the variables of a given Boolean formula can be assigned values (TRUE/FALSE) to make the formula evaluate to TRUE.</p>
                <p>The theorem's significance is profound because it established the first known NP-Complete problem. By showing that any problem in the complexity class NP can be reduced to SAT in polynomial time, it provided a concrete starting point. Subsequently, all other NP-Complete problems were proven by reduction from SAT.</p>
            </div>
        </div>

        <h2 class="text-2xl font-bold text-purple-800 mb-4">Long Answer Questions</h2>

        <!-- NEW Q1 from PDF Page 1 -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <div class="text-lg font-semibold text-purple-700 mb-3">Question 1: Apply DFS on the following graph and give the sequence.</div>
            <div class="text-gray-700 leading-relaxed">
                <div class="graph-container">
                    <!-- DFS Graph from Page 1 -->
                    <svg width="300" height="200" viewBox="0 0 300 200">
                        <!-- Edges -->
                        <line x1="50" y1="100" x2="100" y2="50" class="edge" /> <!-- 0-1 -->
                        <line x1="50" y1="100" x2="100" y2="150" class="edge" /> <!-- 0-2 -->
                        <line x1="100" y1="50" x2="100" y2="150" class="edge" /> <!-- 1-2 -->
                        <line x1="100" y1="50" x2="250" y2="50" class="edge" /> <!-- 1-3 -->
                        <line x1="100" y1="150" x2="250" y2="150" class="edge" /> <!-- 2-4 -->
                        <line x1="250" y1="50" x2="250" y2="150" class="edge" /> <!-- 3-4 -->
                        <!-- Nodes -->
                        <circle cx="50" cy="100" r="20" class="node" /> <text x="50" y="100" class="node-text">0</text>
                        <circle cx="100" cy="50" r="20" class="node" /> <text x="100" y="50" class="node-text">1</text>
                        <circle cx="100" cy="150" r="20" class="node" /> <text x="100" y="150" class="node-text">2</text>
                        <circle cx="250" cy="50" r="20" class="node" /> <text x="250" y="50" class="node-text">3</text>
                        <circle cx="250" cy="150" r="20" class="node" /> <text x="250" y="150" class="node-text">4</text>
                    </svg>
                </div>
                
                <p><strong>Input: Adjacency matrix representation of graph is</strong> {0, 1}, {0, 2}, {1, 2}, {1, 3}, {2, 4}, {3, 4}</p>
                <p><strong>Output:</strong> [0 1 2 3 4]</p>
                
                <p><strong>Explanation:</strong></p>
                <p>In Depth First Search (or DFS) for a graph, we traverse all adjacent vertices one by one. When we traverse an adjacent vertex, we completely finish the traversal of all vertices reachable through that adjacent vertex. This is similar to tree DFS where we first completely traverse the left subtree and then move to the right subtree. The key difference is that, unlike trees, graphs may contain cycles (a node may be visited more than once). To avoid processing a node multiple times, we use a Boolean visited array.</p>

                <p><strong>Note:</strong> There can be multiple DFS traversals of a graph according to the order in which we pick adjacent vertices. Here we pick vertices as per the insertion order.</p>

                <h3>Step-by-Step DFS Traversal:</h3>

                <div class="step-block">
                    <p><strong>Step 01:</strong> Maintain a visited array tracks which nodes have been explored.</p>
                    <table class="dfs-table">
                        <tr>
                            <th colspan="5">visited[] =</th>
                            <td>F</td><td>F</td><td>F</td><td>F</td><td>F</td>
                        </tr>
                        <tr>
                            <th colspan="5">res[] =</th>
                            <td></td><td></td><td></td><td></td><td></td>
                        </tr>
                    </table>
                    <p class="call-stack-box">Call Stack: Empty</p>
                </div>

                <div class="step-block">
                    <p><strong>Step 02:</strong> Iteration 1: DFSRec(adj, visited, 0), Marks visited[0] = true. Call the dfsRec function, So call stack contain dfsRec</p>
                    <table class="dfs-table">
                        <tr>
                            <th>Index:</th>
                            <td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
                        </tr>
                        <tr>
                            <th>visited[] =</th>
                            <td class="visited-cell">T</td><td>F</td><td>F</td><td>F</td><td>F</td>
                        </tr>
                        <tr>
                            <th>res[] =</th>
                            <td class="visited-cell">0</td><td></td><td></td><td></td><td></td>
                        </tr>
                    </table>
                    <p class="call-stack-box">Call Stack: dfsRec(0)</p>
                </div>

                <div class="step-block">
                    <p><strong>Step 03:</strong> Iteration 2: DFSRec(adj, visited, 1), Marks visited[1] = true</p>
                    <table class="dfs-table">
                        <tr>
                            <th>Index:</th>
                            <td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
                        </tr>
                        <tr>
                            <th>visited[] =</th>
                            <td class="visited-cell">T</td><td class="visited-cell">T</td><td>F</td><td>F</td><td>F</td>
                        </tr>
                        <tr>
                            <th>res[] =</th>
                            <td class="visited-cell">0</td><td class="visited-cell">1</td><td></td><td></td><td></td>
                        </tr>
                    </table>
                    <p class="call-stack-box">Call Stack: dfsRec(1) ‚Üí dfsRec(0)</p>
                </div>

                <div class="step-block">
                    <p><strong>Step 04:</strong> Iteration 3: DFSRec(adj, visited, 2), Marks visited[2] = true</p>
                    <table class="dfs-table">
                        <tr>
                            <th>Index:</th>
                            <td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
                        </tr>
                        <tr>
                            <th>visited[] =</th>
                            <td class="visited-cell">T</td><td class="visited-cell">T</td><td class="visited-cell">T</td><td>F</td><td>F</td>
                        </tr>
                        <tr>
                            <th>res[] =</th>
                            <td class="visited-cell">0</td><td class="visited-cell">1</td><td class="visited-cell">2</td><td></td><td></td>
                        </tr>
                    </table>
                    <p class="call-stack-box">Call Stack: dfsRec(2) ‚Üí dfsRec(1) ‚Üí dfsRec(0)</p>
                </div>

                <div class="step-block">
                    <p><strong>Step 05:</strong> Iteration 4: DFSRec(adj, visited, 4), Marks visited[4] = true</p>
                    <table class="dfs-table">
                        <tr>
                            <th>Index:</th>
                            <td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
                        </tr>
                        <tr>
                            <th>visited[] =</th>
                            <td class="visited-cell">T</td><td class="visited-cell">T</td><td class="visited-cell">T</td><td>F</td><td class="visited-cell">T</td>
                        </tr>
                        <tr>
                            <th>res[] =</th>
                            <td class="visited-cell">0</td><td class="visited-cell">1</td><td class="visited-cell">2</td><td></td><td class="visited-cell">4</td>
                        </tr>
                    </table>
                    <p class="call-stack-box">Call Stack: dfsRec(4) ‚Üí dfsRec(2) ‚Üí dfsRec(1) ‚Üí dfsRec(0)</p>
                </div>

                <div class="step-block">
                    <p><strong>Step 06:</strong> Node 4 explores neighbor 3. Marks visited[3] = true</p>
                    <table class="dfs-table">
                        <tr>
                            <th>Index:</th>
                            <td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
                        </tr>
                        <tr>
                            <th>visited[] =</th>
                            <td class="visited-cell">T</td><td class="visited-cell">T</td><td class="visited-cell">T</td><td class="visited-cell">T</td><td class="visited-cell">T</td>
                        </tr>
                        <tr>
                            <th>res[] =</th>
                            <td class="visited-cell">0</td><td class="visited-cell">1</td><td class="visited-cell">2</td><td class="visited-cell">4</td><td class="visited-cell">3</td>
                        </tr>
                    </table>
                    <p class="call-stack-box">Call Stack: dfsRec(3) ‚Üí dfsRec(4) ‚Üí dfsRec(2) ‚Üí dfsRec(1) ‚Üí dfsRec(0)</p>
                    <p><em>Node 3 has no unvisited neighbors, so we backtrack.</em></p>
                </div>

                <div class="step-block">
                    <p><strong>Step 07:</strong> Backtracking from node 3 to 4</p>
                    <table class="dfs-table">
                        <tr>
                            <th>Index:</th>
                            <td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
                        </tr>
                        <tr>
                            <th>visited[] =</th>
                            <td class="visited-cell">T</td><td class="visited-cell">T</td><td class="visited-cell">T</td><td class="visited-cell">T</td><td class="visited-cell">T</td>
                        </tr>
                        <tr>
                            <th>res[] =</th>
                            <td class="visited-cell">0</td><td class="visited-cell">1</td><td class="visited-cell">2</td><td class="visited-cell">4</td><td class="visited-cell">3</td>
                        </tr>
                    </table>
                    <p class="call-stack-box">Call Stack: dfsRec(2) ‚Üí dfsRec(1) ‚Üí dfsRec(0)</p>
                </div>

                <div class="step-block">
                    <p><strong>Step 08:</strong> Backtracking from 4 to 2, then from 2 to 1</p>
                    <table class="dfs-table">
                        <tr>
                            <th>Index:</th>
                            <td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
                        </tr>
                        <tr>
                            <th>visited[] =</th>
                            <td class="visited-cell">T</td><td class="visited-cell">T</td><td class="visited-cell">T</td><td class="visited-cell">T</td><td class="visited-cell">T</td>
                        </tr>
                        <tr>
                            <th>res[] =</th>
                            <td class="visited-cell">0</td><td class="visited-cell">1</td><td class="visited-cell">2</td><td class="visited-cell">4</td><td class="visited-cell">3</td>
                        </tr>
                    </table>
                    <p class="call-stack-box">Call Stack: dfsRec(1) ‚Üí dfsRec(0)</p>
                    <p><em>Node 1 explores neighbor 3, but it's already visited, continue backtracking.</em></p>
                </div>

                <div class="step-block">
                    <p><strong>Step 09:</strong> Backtracking from 1 to 0</p>
                    <table class="dfs-table">
                        <tr>
                            <th>Index:</th>
                            <td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
                        </tr>
                        <tr>
                            <th>visited[] =</th>
                            <td class="visited-cell">T</td><td class="visited-cell">T</td><td class="visited-cell">T</td><td class="visited-cell">T</td><td class="visited-cell">T</td>
                        </tr>
                        <tr>
                            <th>res[] =</th>
                            <td class="visited-cell">0</td><td class="visited-cell">1</td><td class="visited-cell">2</td><td class="visited-cell">4</td><td class="visited-cell">3</td>
                        </tr>
                    </table>
                    <p class="call-stack-box">Call Stack: dfsRec(0)</p>
                    <p><em>Node 0 checks neighbor 2, but it's already visited.</em></p>
                </div>

                <div class="step-block">
                    <p><strong>Step 10:</strong> DFS from source: 0</p>
                    <p><strong>Final Output:</strong> 0 1 2 4 3</p>
                    <table class="dfs-table">
                        <tr>
                            <th>Index:</th>
                            <td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
                        </tr>
                        <tr>
                            <th>visited[] =</th>
                            <td class="visited-cell">T</td><td class="visited-cell">T</td><td class="visited-cell">T</td><td class="visited-cell">T</td><td class="visited-cell">T</td>
                        </tr>
                        <tr>
                            <th>res[] =</th>
                            <td class="visited-cell">0</td><td class="visited-cell">1</td><td class="visited-cell">2</td><td class="visited-cell">4</td><td class="visited-cell">3</td>
                        </tr>
                    </table>
                    <p class="call-stack-box">Call Stack: Empty (All nodes visited)</p>
                </div>

                <h3>DFS Algorithm Flow Summary:</h3>
                <ol>
                    <li>Start at 0: Mark as visited. Output: 0</li>
                    <li>Move to 1: Mark as visited. Output: 1</li>
                    <li>Move to 2: Mark as visited. Output: 2</li>
                    <li>Move to 4: Mark as visited. Output: 4</li>
                    <li>Move to 3: Mark as visited. Output: 3 (backtrack to 4, then backtrack to 2, then backtrack to 1, then to 0)</li>
                </ol>

                <p><strong>Final DFS Traversal Sequence:</strong> 0 ‚Üí 1 ‚Üí 2 ‚Üí 4 ‚Üí 3</p>
                
                <p><strong>Note:</strong> Not that there can be more than one DFS Traversals of a Graph. For example, after 1, we may pick adjacent 2 instead of 0 and get a different DFS. Here we pick in the insertion order.</p>
            </div>
        </div>

        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <div class="text-lg font-semibold text-purple-700 mb-3">Question 2: Apply TSP on Graph (A,B,C,D,E,F).</div>
            <div class="text-gray-700 leading-relaxed">
                <p><strong>Solution Steps:</strong></p>
                
                <div class="step-block">
                    <p class="step-text">1. From the given graph, since the origin is already mentioned (A), the solution must always start from that node. Among the edges leading from A, \(A \rightarrow B\) (16) has the shortest distance.</p>
                    <div class="graph-container">
                        <svg width="150" height="100" viewBox="0 0 150 100">
                            <line x1="20" y1="80" x2="60" y2="20" class="edge-highlight" />
                            <text x="30" y="50" class="edge-label">16</text>
                            <circle cx="20" cy="80" r="12" class="node" /><text x="20" y="80" class="node-text">A</text>
                            <circle cx="60" cy="20" r="12" class="node" /><text x="60" y="20" class="node-text">B</text>
                        </svg>
                    </div>
                </div>

                <div class="step-block">
                    <p class="step-text">2. Then, \(B \rightarrow C\) (21) has the shortest and only edge between, therefore it is included.</p>
                    <div class="graph-container">
                        <svg width="200" height="100" viewBox="0 0 200 100">
                            <line x1="20" y1="80" x2="60" y2="20" class="edge-highlight" />
                            <line x1="60" y1="20" x2="140" y2="20" class="edge-highlight" />
                            <circle cx="20" cy="80" r="12" class="node" /><text x="20" y="80" class="node-text">A</text>
                            <circle cx="60" cy="20" r="12" class="node" /><text x="60" y="20" class="node-text">B</text>
                            <circle cx="140" cy="20" r="12" class="node" /><text x="140" y="20" class="node-text">C</text>
                        </svg>
                    </div>
                </div>

                <div class="step-block">
                    <p class="step-text">3. There is only one edge between \(C \rightarrow D\) (12), therefore it is added.</p>
                    <div class="graph-container">
                        <svg width="250" height="100" viewBox="0 0 250 100">
                            <line x1="20" y1="80" x2="60" y2="20" class="edge-highlight" />
                            <line x1="60" y1="20" x2="140" y2="20" class="edge-highlight" />
                            <line x1="140" y1="20" x2="200" y2="60" class="edge-highlight" />
                            <circle cx="20" cy="80" r="12" class="node" /><text x="20" y="80" class="node-text">A</text>
                            <circle cx="60" cy="20" r="12" class="node" /><text x="60" y="20" class="node-text">B</text>
                            <circle cx="140" cy="20" r="12" class="node" /><text x="140" y="20" class="node-text">C</text>
                            <circle cx="200" cy="60" r="12" class="node" /><text x="200" y="60" class="node-text">D</text>
                        </svg>
                    </div>
                </div>

                <div class="step-block">
                    <p class="step-text">4. There are two outward edges from D. Even though \(D \rightarrow B\) has lower distance than \(D \rightarrow E\), B is already visited. Therefore, \(D \rightarrow E\) (15) is added.</p>
                    <p class="step-text">5. There is only one edge from E, that is \(E \rightarrow F\) (16).</p>
                    <p class="step-text">6. Finally, \(F \rightarrow A\) (34) is added to return to start and avoid cycling C.</p>
                    <div class="graph-container">
                        <!-- Final Path Graph -->
                        <svg width="350" height="150" viewBox="0 0 350 150">
                            <line x1="20" y1="80" x2="60" y2="20" class="edge-highlight" />
                            <line x1="60" y1="20" x2="140" y2="20" class="edge-highlight" />
                            <line x1="140" y1="20" x2="200" y2="60" class="edge-highlight" />
                            <line x1="200" y1="60" x2="160" y2="120" class="edge-highlight" /> <!-- D-E -->
                            <line x1="160" y1="120" x2="80" y2="120" class="edge-highlight" /> <!-- E-F -->
                            <line x1="80" y1="120" x2="20" y2="80" class="edge-highlight" /> <!-- F-A -->

                            <text x="30" y="45" class="edge-label">16</text>
                            <text x="100" y="15" class="edge-label">21</text>
                            <text x="180" y="35" class="edge-label">12</text>
                            <text x="190" y="100" class="edge-label">15</text>
                            <text x="120" y="135" class="edge-label">16</text>
                            <text x="35" y="110" class="edge-label">34</text>

                            <circle cx="20" cy="80" r="12" class="node" /><text x="20" y="80" class="node-text">A</text>
                            <circle cx="60" cy="20" r="12" class="node" /><text x="60" y="20" class="node-text">B</text>
                            <circle cx="140" cy="20" r="12" class="node" /><text x="140" y="20" class="node-text">C</text>
                            <circle cx="200" cy="60" r="12" class="node" /><text x="200" y="60" class="node-text">D</text>
                            <circle cx="160" cy="120" r="12" class="node" /><text x="160" y="120" class="node-text">E</text>
                            <circle cx="80" cy="120" r="12" class="node" /><text x="80" y="120" class="node-text">F</text>
                        </svg>
                    </div>
                </div>

                <p><strong>Shortest Path found:</strong> \(A \rightarrow B \rightarrow C \rightarrow D \rightarrow E \rightarrow F \rightarrow A\)</p>
                <p><strong>Cost:</strong> \(16 + 21 + 12 + 15 + 16 + 34 = 114\)</p>
            </div>
        </div>

        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <div class="text-lg font-semibold text-purple-700 mb-3">Question 3: Apply BFS on the following graph.</div>
            <div class="text-gray-700 leading-relaxed">
                <div class="graph-container">
                     <!-- BFS Graph from Page 4 -->
                     <svg width="300" height="200" viewBox="0 0 300 200">
                        <line x1="50" y1="100" x2="100" y2="50" class="edge" />
                        <line x1="50" y1="100" x2="100" y2="150" class="edge" />
                        <line x1="100" y1="50" x2="100" y2="150" class="edge" />
                        <line x1="100" y1="50" x2="250" y2="50" class="edge" />
                        <line x1="100" y1="150" x2="250" y2="150" class="edge" />
                        <line x1="250" y1="50" x2="250" y2="150" class="edge" />
                        <circle cx="50" cy="100" r="20" class="node" /> <text x="50" y="100" class="node-text">0</text>
                        <circle cx="100" cy="50" r="20" class="node" /> <text x="100" y="50" class="node-text">1</text>
                        <circle cx="100" cy="150" r="20" class="node" /> <text x="100" y="150" class="node-text">2</text>
                        <circle cx="250" cy="50" r="20" class="node" /> <text x="250" y="50" class="node-text">3</text>
                        <circle cx="250" cy="150" r="20" class="node" /> <text x="250" y="150" class="node-text">4</text>
                    </svg>
                </div>
                
                <p><strong>BFS (Breadth-First Search)</strong> is a graph traversal algorithm that explores vertices level by level. Starting from a source vertex, it visits all neighbors at the current depth before moving to vertices at the next depth level. Unlike DFS which uses a stack (recursion), BFS uses a queue data structure.</p>
                
                <p><strong>Note:</strong> BFS can have multiple traversal sequences depending on the order in which we pick adjacent vertices. Here we pick vertices in ascending order.</p>
                
                <p><strong>Step-by-Step BFS Traversal (Starting from vertex 0):</strong></p>
                
                <div class="step-block">
                    <p class="step-text"><strong>Step 01:</strong> Initialize: Mark starting vertex 0 as visited and enqueue it.</p>
                    <table class="dfs-table">
                        <tr>
                            <th style="background-color: #a855f7;">visited[] =</th>
                            <td>T</td>
                            <td>F</td>
                            <td>F</td>
                            <td>F</td>
                            <td>F</td>
                        </tr>
                        <tr>
                            <th style="background-color: #a855f7;">Queue =</th>
                            <td colspan="5">[0]</td>
                        </tr>
                    </table>
                    <div class="call-stack-box">Output: []</div>
                </div>
                
                <div class="step-block">
                    <p class="step-text"><strong>Step 02:</strong> Dequeue 0, process it (add to output), then enqueue its unvisited neighbors: 1 and 2.</p>
                    <table class="dfs-table">
                        <tr>
                            <th style="background-color: #a855f7;">Index:</th>
                            <td>0</td>
                            <td>1</td>
                            <td>2</td>
                            <td>3</td>
                            <td>4</td>
                        </tr>
                        <tr>
                            <th style="background-color: #a855f7;">visited[] =</th>
                            <td class="visited-cell">T</td>
                            <td class="visited-cell">T</td>
                            <td class="visited-cell">T</td>
                            <td>F</td>
                            <td>F</td>
                        </tr>
                        <tr>
                            <th style="background-color: #a855f7;">Queue =</th>
                            <td colspan="5">[1, 2]</td>
                        </tr>
                    </table>
                    <div class="call-stack-box">Output: [0]</div>
                </div>
                
                <div class="step-block">
                    <p class="step-text"><strong>Step 03:</strong> Dequeue 1, process it, enqueue unvisited neighbors: 3 (vertex 0 and 2 already visited).</p>
                    <table class="dfs-table">
                        <tr>
                            <th style="background-color: #a855f7;">Index:</th>
                            <td>0</td>
                            <td>1</td>
                            <td>2</td>
                            <td>3</td>
                            <td>4</td>
                        </tr>
                        <tr>
                            <th style="background-color: #a855f7;">visited[] =</th>
                            <td class="visited-cell">T</td>
                            <td class="visited-cell">T</td>
                            <td class="visited-cell">T</td>
                            <td class="visited-cell">T</td>
                            <td>F</td>
                        </tr>
                        <tr>
                            <th style="background-color: #a855f7;">Queue =</th>
                            <td colspan="5">[2, 3]</td>
                        </tr>
                    </table>
                    <div class="call-stack-box">Output: [0, 1]</div>
                </div>
                
                <div class="step-block">
                    <p class="step-text"><strong>Step 04:</strong> Dequeue 2, process it, enqueue unvisited neighbor: 4 (vertices 0 and 1 already visited).</p>
                    <table class="dfs-table">
                        <tr>
                            <th style="background-color: #a855f7;">Index:</th>
                            <td>0</td>
                            <td>1</td>
                            <td>2</td>
                            <td>3</td>
                            <td>4</td>
                        </tr>
                        <tr>
                            <th style="background-color: #a855f7;">visited[] =</th>
                            <td class="visited-cell">T</td>
                            <td class="visited-cell">T</td>
                            <td class="visited-cell">T</td>
                            <td class="visited-cell">T</td>
                            <td class="visited-cell">T</td>
                        </tr>
                        <tr>
                            <th style="background-color: #a855f7;">Queue =</th>
                            <td colspan="5">[3, 4]</td>
                        </tr>
                    </table>
                    <div class="call-stack-box">Output: [0, 1, 2]</div>
                </div>
                
                <div class="step-block">
                    <p class="step-text"><strong>Step 05:</strong> Dequeue 3, process it. All neighbors (1 and 4) already visited or in queue.</p>
                    <table class="dfs-table">
                        <tr>
                            <th style="background-color: #a855f7;">Index:</th>
                            <td>0</td>
                            <td>1</td>
                            <td>2</td>
                            <td>3</td>
                            <td>4</td>
                        </tr>
                        <tr>
                            <th style="background-color: #a855f7;">visited[] =</th>
                            <td class="visited-cell">T</td>
                            <td class="visited-cell">T</td>
                            <td class="visited-cell">T</td>
                            <td class="visited-cell">T</td>
                            <td class="visited-cell">T</td>
                        </tr>
                        <tr>
                            <th style="background-color: #a855f7;">Queue =</th>
                            <td colspan="5">[4]</td>
                        </tr>
                    </table>
                    <div class="call-stack-box">Output: [0, 1, 2, 3]</div>
                </div>
                
                <div class="step-block">
                    <p class="step-text"><strong>Step 06:</strong> Dequeue 4, process it. All neighbors already visited. Queue is now empty.</p>
                    <table class="dfs-table">
                        <tr>
                            <th style="background-color: #a855f7;">Index:</th>
                            <td>0</td>
                            <td>1</td>
                            <td>2</td>
                            <td>3</td>
                            <td>4</td>
                        </tr>
                        <tr>
                            <th style="background-color: #a855f7;">visited[] =</th>
                            <td class="visited-cell">T</td>
                            <td class="visited-cell">T</td>
                            <td class="visited-cell">T</td>
                            <td class="visited-cell">T</td>
                            <td class="visited-cell">T</td>
                        </tr>
                        <tr>
                            <th style="background-color: #a855f7;">Queue =</th>
                            <td colspan="5">[]</td>
                        </tr>
                    </table>
                    <div class="call-stack-box">Output: [0, 1, 2, 3, 4]</div>
                </div>
                
                <p><strong>Final BFS Traversal Sequence:</strong> 0 &rarr; 1 &rarr; 2 &rarr; 3 &rarr; 4</p>
            </div>
        </div>

        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <div class="text-lg font-semibold text-purple-700 mb-3">Question 4: Implement Travelling Salesman Problem in C/C++/Java/Python.</div>
            <div class="text-gray-700 leading-relaxed">
                <div class="code-tabs">
                    <div class="tab-header">
                        <button class="tab-btn active" onclick="openTab(event, 'tsp-cpp')">C++</button>
                        <button class="tab-btn" onclick="openTab(event, 'tsp-java')">Java</button>
                        <button class="tab-btn" onclick="openTab(event, 'tsp-python')">Python</button>
                    </div>
                    
                    <div id="tsp-cpp" class="tab-content active">
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
using namespace std;

int V = 4;

int travellingSalesmanProblem(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int s) {
    vector&lt;int&gt; vertex;
    for (int i = 0; i &lt; V; i++)
        if (i != s)
            vertex.push_back(i);
    
    int min_path = INT_MAX;
    
    do {
        int current_pathweight = 0;
        int k = s;
        
        for (int i = 0; i &lt; vertex.size(); i++) {
            current_pathweight += graph[k][vertex[i]];
            k = vertex[i];
        }
        current_pathweight += graph[k][s];
        
        min_path = min(min_path, current_pathweight);
        
    } while (next_permutation(vertex.begin(), vertex.end()));
    
    return min_path;
}

int main() {
    vector&lt;vector&lt;int&gt;&gt; graph = {
        {0, 10, 15, 20},
        {10, 0, 35, 25},
        {15, 35, 0, 30},
        {20, 25, 30, 0}
    };
    int s = 0;
    cout &lt;&lt; "Min Cost: " &lt;&lt; travellingSalesmanProblem(graph, s) &lt;&lt; endl;
    return 0;
}</code></pre>
                    </div>
                    
                    <div id="tsp-java" class="tab-content">
<pre><code>import java.util.*;

public class TSP {
    static int V = 4;
    
    static int travellingSalesmanProblem(int[][] graph, int s) {
        List&lt;Integer&gt; vertex = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; V; i++)
            if (i != s)
                vertex.add(i);
        
        int min_path = Integer.MAX_VALUE;
        
        do {
            int current_pathweight = 0;
            int k = s;
            
            for (int i = 0; i &lt; vertex.size(); i++) {
                current_pathweight += graph[k][vertex.get(i)];
                k = vertex.get(i);
            }
            current_pathweight += graph[k][s];
            
            min_path = Math.min(min_path, current_pathweight);
            
        } while (nextPermutation(vertex));
        
        return min_path;
    }
    
    static boolean nextPermutation(List&lt;Integer&gt; arr) {
        int i = arr.size() - 2;
        while (i &gt;= 0 &amp;&amp; arr.get(i) &gt;= arr.get(i + 1))
            i--;
        
        if (i &lt; 0)
            return false;
        
        int j = arr.size() - 1;
        while (arr.get(j) &lt;= arr.get(i))
            j--;
        
        Collections.swap(arr, i, j);
        Collections.reverse(arr.subList(i + 1, arr.size()));
        return true;
    }
    
    public static void main(String[] args) {
        int[][] graph = {
            {0, 10, 15, 20},
            {10, 0, 35, 25},
            {15, 35, 0, 30},
            {20, 25, 30, 0}
        };
        int s = 0;
        System.out.println("Min Cost: " + travellingSalesmanProblem(graph, s));
    }
}</code></pre>
                    </div>
                    
                    <div id="tsp-python" class="tab-content">
<pre><code>from sys import maxsize
from itertools import permutations

V = 4
def travellingSalesmanProblem(graph, s):
    vertex = []
    for i in range(V):
        if i != s:
            vertex.append(i)
    min_path = maxsize
    next_permutation=permutations(vertex)
    
    for i in next_permutation:
        current_pathweight = 0
        k = s
        for j in i:
            current_pathweight += graph[k][j]
            k = j
        current_pathweight += graph[k][s]
        min_path = min(min_path, current_pathweight)
        
    return min_path

# Matrix representation of graph
graph = [[0, 10, 15, 20], 
         [10, 0, 35, 25], 
         [15, 35, 0, 30], 
         [20, 25, 30, 0]]
s = 0
print("Min Cost:", travellingSalesmanProblem(graph, s))</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <div class="text-lg font-semibold text-purple-700 mb-3">Question 5: Implement BFS Technique in C/C++/Java/Python.</div>
            <div class="text-gray-700 leading-relaxed">
                <div class="code-tabs">
                    <div class="tab-header">
                        <button class="tab-btn active" onclick="openTab(event, 'bfs-cpp')">C++</button>
                        <button class="tab-btn" onclick="openTab(event, 'bfs-java')">Java</button>
                        <button class="tab-btn" onclick="openTab(event, 'bfs-python')">Python</button>
                    </div>
                    
                    <div id="bfs-cpp" class="tab-content active">
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
using namespace std;

void bfs(map&lt;int, vector&lt;int&gt;&gt;&amp; graph, int start) {
    set&lt;int&gt; visited;
    queue&lt;int&gt; q;
    
    q.push(start);
    visited.insert(start);
    
    while (!q.empty()) {
        int vertex = q.front();
        q.pop();
        cout &lt;&lt; vertex &lt;&lt; " ";
        
        for (int neighbor : graph[vertex]) {
            if (visited.find(neighbor) == visited.end()) {
                visited.insert(neighbor);
                q.push(neighbor);
            }
        }
    }
}

int main() {
    map&lt;int, vector&lt;int&gt;&gt; graph = {
        {0, {1, 2}},
        {1, {2}},
        {2, {0, 3}},
        {3, {3}}
    };
    
    cout &lt;&lt; "BFS Traversal: ";
    bfs(graph, 2);
    cout &lt;&lt; endl;
    
    return 0;
}</code></pre>
                    </div>
                    
                    <div id="bfs-java" class="tab-content">
<pre><code>import java.util.*;

public class BFS {
    static void bfs(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, int start) {
        Set&lt;Integer&gt; visited = new HashSet&lt;&gt;();
        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        
        queue.add(start);
        visited.add(start);
        
        while (!queue.isEmpty()) {
            int vertex = queue.poll();
            System.out.print(vertex + " ");
            
            for (int neighbor : graph.get(vertex)) {
                if (!visited.contains(neighbor)) {
                    visited.add(neighbor);
                    queue.add(neighbor);
                }
            }
        }
    }
    
    public static void main(String[] args) {
        Map&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;();
        graph.put(0, Arrays.asList(1, 2));
        graph.put(1, Arrays.asList(2));
        graph.put(2, Arrays.asList(0, 3));
        graph.put(3, Arrays.asList(3));
        
        System.out.print("BFS Traversal: ");
        bfs(graph, 2);
        System.out.println();
    }
}</code></pre>
                    </div>
                    
                    <div id="bfs-python" class="tab-content">
<pre><code>from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)

    while queue:
        vertex = queue.popleft()
        print(str(vertex) + " ", end="")

        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

# Graph represented as Adjacency List
graph = {
    0: [1, 2],
    1: [2],
    2: [0, 3],
    3: [3]
}
print("BFS Traversal:")
bfs(graph, 2)</code></pre>
                    </div>
                </div>
            </div>
        </div>
    </main>
    </div>

    <script>
    function openTab(evt, tabName) {
        var i, tabContent, tabBtns;
        
        tabContent = document.getElementsByClassName("tab-content");
        for (i = 0; i < tabContent.length; i++) {
            tabContent[i].classList.remove("active");
        }
        
        tabBtns = document.getElementsByClassName("tab-btn");
        for (i = 0; i < tabBtns.length; i++) {
            tabBtns[i].classList.remove("active");
        }
        
        document.getElementById(tabName).classList.add("active");
        evt.currentTarget.classList.add("active");
    }
    </script>

    <!-- Footer -->
    <footer class="bg-purple-900 text-white py-6 mt-12">
        <div class="max-w-7xl mx-auto px-4 text-center">
            <p class="mb-2">&copy; 2025 MCA Study Portal | Happy Learning! üéì</p>
            <p class="mb-2">Developed by - <a href="../Developer.html" class="underline font-semibold hover:text-purple-300">Satyam Sharma</a></p>
            <p>
                <a href="../Developer.html" class="underline hover:text-purple-300">Email: satyamxwork@gmail.com</a> | 
                <a href="../Developer.html" class="underline hover:text-purple-300">Mob: 6264616250</a>
            </p>
        </div>
    </footer>
</body>
</html>